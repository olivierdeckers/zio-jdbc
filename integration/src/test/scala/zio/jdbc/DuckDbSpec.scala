package zio.jdbc

import org.duckdb.DuckDBConnection
import org.testcontainers.jdbc.ConnectionWrapper
import zio._
import zio.schema.{ DeriveSchema, Schema }
import zio.test.TestAspect.{ repeats, sequential, shrinks, withLiveClock }
import zio.test.{ Gen, Spec, TestEnvironment, ZIOSpec, assertTrue, check }

import java.sql.{ Array => _, _ }
import java.time.{ OffsetDateTime, ZoneOffset }
import java.time.temporal.ChronoUnit
import java.util.Properties

object DuckDbSpec extends ZIOSpec[ZConnection] {

  override def bootstrap: ZLayer[Any, Any, ZConnection] =
    ZLayer.scoped(
      for {
        connection  <- ZIO.acquireRelease(
                         ZIO.succeedBlocking {
                           val props  = new Properties()
                           val duckDb = DriverManager
                             .getConnection(s"jdbc:duckdb:", props)
                             .asInstanceOf[DuckDBConnection]
                           WorkaroundDuckDBConnection(duckDb)
                         }
                       )(c => ZIO.succeed(c.close()))
        zConnection <- ZConnection.make(connection)
      } yield zConnection
    )

  case class OffsetDateTimeRow(value: OffsetDateTime)
  object OffsetDateTimeRow {
    implicit val schema: Schema[OffsetDateTimeRow]           = DeriveSchema.gen[OffsetDateTimeRow]
    implicit val jdbcDecoder: JdbcDecoder[OffsetDateTimeRow] = JdbcDecoder.fromSchema
  }

  override def spec: Spec[ZConnection with TestEnvironment with Scope, Any] = suite("DuckDB")(
    test("should be able to decode case classes with OffsetDateTime fields and handle timezones correctly") {
      check(
        Gen.offsetDateTime(
          OffsetDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC),
          OffsetDateTime.of(2100, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC)
        )
      ) { offsetDateTime =>
        for {
          _       <- sql"""CREATE TABLE offset_datetime (value TIMESTAMP WITH TIME ZONE)""".execute
          _       <- sql"""INSERT INTO offset_datetime VALUES ($offsetDateTime)""".execute
          d       <- sql"""SELECT value FROM offset_datetime""".query[OffsetDateTimeRow].selectOne
          _       <- sql"DROP TABLE offset_datetime".execute
          expected =
            offsetDateTime
              .truncatedTo(ChronoUnit.MICROS)
              .withOffsetSameInstant(ZoneOffset.UTC)
        } yield assertTrue(
          d.isDefined,
          d.get.value == expected
        )
      }
    }
  ) @@ sequential @@ shrinks(0) @@ repeats(100) @@ withLiveClock

  val noop = new Runnable() {
    override def run(): Unit = ()
  }

  /**
   * The DuckDBConnection hasn't implemented some operations that are used by zio-jdbc. This class works around those.
   */
  case class WorkaroundDuckDBConnection(duckDb: DuckDBConnection) extends ConnectionWrapper(duckDb, noop) {
    // Work around this feature not being implemented by duckdb jdbc
    override def prepareStatement(sql: String, autoGeneratedKeys: Int): PreparedStatement = prepareStatement(sql)
    override def getClientInfo(name: String): String                                      = null
    override def getClientInfo: Properties                                                = new Properties()
  }

}
